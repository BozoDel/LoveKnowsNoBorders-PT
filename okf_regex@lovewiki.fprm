#v1
regexOptions.i=8
startString="
endString="
extractOuterStrings.b=false
useBSlashEscape.b=true
useDoubleCharEscape.b=false
mimeType=text/plain
oneLevelGroups.b=false
useLd.b=true
localizeOutside.b=true
ruleCount.i=17
rule0.ruleName=bracketSkips
rule0.ruleType.i=3
rule0.expr=(\*\s*)?\[{2}(Category|File):[^]]*\]{2}
rule0.groupSource.i=-1
rule0.groupTarget.i=-1
rule0.groupName.i=-1
rule0.groupNote.i=-1
rule0.preserveWS.b=true
rule0.useCodeFinder.b=false
rule0.sample=MUST BE PLACED ABOVE paragraph$0a$(because structures starting with "[[" are matched by it)$0a$$0a$Skips some things inside contained by "[[ ]]",$0a$"Category:" and "File:" because they should remain unchanged.$0a$$0a$[[File:SourceControls.png|400px]]$0a$$0a$[[Category:Types]]
rule0.codeFinderRules.count.i=0
rule0.codeFinderRules.sample=
rule0.codeFinderRules.useAllRulesWhenTesting.b=false
rule1.ruleName=paragraph
rule1.ruleType.i=1
rule1.expr=((?<=[.?!] )|^)([\w\[\('].*?)($|(?<=[.?!])(?= ))
rule1.groupSource.i=2
rule1.groupTarget.i=-1
rule1.groupName.i=-1
rule1.groupNote.i=-1
rule1.preserveWS.b=true
rule1.useCodeFinder.b=true
rule1.sample=MUST BE PLACED BELOW bracketSkips$0a$(because of structures starting with "[[" that must be skipped)$0a$$0a$Matches whole paragraphs. It's not necessary to have the CAT tool further segment paragraphs.$0a$$0a$They can end with a period. With a question mark? With an exclamation point! Or just a letter (or anything else) in the end of paragraphs$0a$$0a$[[It can start]] with a [link]$0a$(Or with parentheses)$0a$''Or with italic''$0a$'''Or bold'''$0a$'''''Or both'''''$0a$$0a$Explanation of the regex:$0a$It must be preceded by a ".", a "?" or a "!" plus a space OR be at the start of the line.$0a$The first character has to be a letter, a "[", a "(", or a "'", in order not to$0a$conflict with things that start with "{" or "=", for example.$0a$The following characters are of any kind, but with a lazy quantifier, until it satisfies$0a$the final conditions.$0a$The final condition is end of line OR be preceded by ".", "?" or "!" AND followed by$0a$a space.$0a$It might seem overkill, but we are dealing with function names that have dots in$0a$them. Done this way, that's not an issue.$0a$$0a$*"[]" and "[[]]" are no longer treated as inline code, since they're not simple tags, but$0a$complex structures that often require addition of arguments separated by "|".
rule1.codeFinderRules.count.i=2
rule1.codeFinderRules.sample=Matches whole paragraphs. That will be further segmented by the CAT tool.$0a$$0a$They can end with a period.$0a$With a question mark?$0a$With an exclamation point!$0a$With a colon:$0a$Or just a letter$0a$$0a$[[It can start]] and end with a [link]$0a$(Or with parentheses)$0a$<span style="color: #597E9A; font-size: 18pt">Or with an HTML lovely span, wonderful span</span>$0a$''Or with italic''$0a$'''Or bold'''$0a$'''''Or both'''''$0a$$0a$Like <code>[[love.event.poll]]()</code>, but blocks until there is an event in the queue.
rule1.codeFinderRules.useAllRulesWhenTesting.b=true
rule2.ruleName=headings
rule2.ruleType.i=1
rule2.expr=(={2,6})\s*(.+?)\s*\1
rule2.groupSource.i=2
rule2.groupTarget.i=-1
rule2.groupName.i=-1
rule2.groupNote.i=1
rule2.preserveWS.b=true
rule2.useCodeFinder.b=false
rule2.sample=Selects wikimedia headings, which are marked by 2 to 6 equals signs on each side.$0a$The \s is because we don't want any unnecessary spaces sent to the translation,$0a$though that may not be really necessary. first group (containing equal signs) will$0a$serve as segment ID, to clarify that it's a heading.$0a$$0a$I the examples below, there are some buggy ones that are very unlikely to$0a$occur.$0a$$0a$= not valid =$0a$== second header ==$0a$=== third header ===$0a$==== fourth header ====$0a$===== fifth header =====$0a$======  sixth header ======$0a$======= not valid and buggy =======$0a$== another buggy one ====$0a$some text for showing the bug$0a$== second header not captured because of bug ==
rule2.codeFinderRules.count.i=0
rule2.codeFinderRules.sample=
rule2.codeFinderRules.useAllRulesWhenTesting.b=false
rule3.ruleName=bracesSkips
rule3.ruleType.i=3
rule3.expr=\{{2}(i18n\||#(ask|set:(Since|RealLink)=)|newobjectnotice)[^}]*}{2}
rule3.groupSource.i=-1
rule3.groupTarget.i=-1
rule3.groupName.i=-1
rule3.groupNote.i=-1
rule3.preserveWS.b=true
rule3.useCodeFinder.b=false
rule3.sample=Does not extract the i18n template occurrences, inline queries (#ask),$0a$Since and RealLink property settings (#set) and newobjectnotice.$0a$Those are either to be untouched, or have had their parts automatically replaced$0a$already.$0a$$0a${{#set:RealLink=love.audio.pause (Português)}}$0a$$0a${{newobjectnotice (Português)}}$0a$$0a${{#ask: [[Category:Types]] [[parent::love.audio]] [[Concept:Current]]$0a$| headers=hide$0a$| format=template$0a$| template=ListingFields$0a$| introtemplate=ListingIntro$0a$| outrotemplate=ListingOutro$0a$| ?Description$0a$| ?PrettySince$0a$| ?PrettyRemoved$0a$}}$0a$$0a${{#set:Since=000}}$0a$$0a${{i18n|love.audio}}$0a$
rule3.codeFinderRules.count.i=0
rule3.codeFinderRules.sample=
rule3.codeFinderRules.useAllRulesWhenTesting.b=false
rule4.ruleName=noticeDescriptionDisplay
rule4.ruleType.i=1
rule4.expr=\{{2}(notice\||#set:(Description|DisplayName)=)([^}]*)}{2}
rule4.groupSource.i=3
rule4.groupTarget.i=-1
rule4.groupName.i=-1
rule4.groupNote.i=1
rule4.preserveWS.b=true
rule4.useCodeFinder.b=false
rule4.sample=Matches notices and Description and DisplayName properties, which are sent to$0a$translation. The first capturing group is used as an identifier.$0a$$0a${{notice|There's a bug in [[0.8.0]] preventing this function from working}}$0a$$0a${{#set:DisplayName=love.audio.pause}}$0a$$0a${{#set:Description=Creates a new [[Source]] from a file, [[SoundData]], or [[Decoder]].}}$0a$$0a$*"[]" and "[[]]" are no longer treated as inline code, since they're not simple tags, but$0a$complex structures that often require addition of arguments separated by "|".
rule4.codeFinderRules.count.i=0
rule4.codeFinderRules.sample=
rule4.codeFinderRules.useAllRulesWhenTesting.b=false
rule5.ruleName=internalLinks
rule5.ruleType.i=1
rule5.expr=\*\s*\[{2}((parent|Constructs)::|).*?]]
rule5.groupSource.i=0
rule5.groupTarget.i=-1
rule5.groupName.i=-1
rule5.groupNote.i=1
rule5.preserveWS.b=true
rule5.useCodeFinder.b=true
rule5.sample=This captures bracket links that come after a "*".$0a$That structure is found (exclusively?) at the "See Also" section.$0a$"*", "[[" and "]]" are not being considered inline code (and are thus not being$0a$transformed into tags), because the link structure is often a bit complex, demanding$0a$the addition of an extra parameter separated by "|" (but not always). So it must not$0a$be confused with regular tags (such as bold and italics).$0a$In the case below, Tutorial:Audio is a non-essential part of the wiki, and the$0a$translators could choose not to translate it, so the link should remain the same.$0a$The inline code is not transformed into tags also  to make translators more aware of$0a$the situation, and remind them that they should edit the link manually, using the$0a$appropriate syntax:$0a$[[PageRealAndDisplayName]] or [[PageRealName|PageDisplayName]]$0a$$0a$Some of them start with "parent::" or "Constructs::". Unlike in the example of$0a$"Tutorial:Audio", they're not part of the link. Instead, they provide the link AND set$0a$the parent/Constructs property. "[[Constructs::Source]]" would have to be translated$0a$as "[[Constructs::Source (Português)|Fonte]]" (for the Portuguese language). With$0a$that in mind, "parent::" and "Constructs::" will be considered inline code (to separate$0a$it more clearly) and also used as an identifier.$0a$$0a$== See Also ==$0a$* [[parent::love]]$0a$* [[Tutorial:Audio]]$0a$* [[Constructs::Source]]
rule5.codeFinderRules.count.i=1
rule5.codeFinderRules.sample=* [[parent::love]]$0a$* [[Tutorial:Audio]]$0a$* [[Constructs::Source]]
rule5.codeFinderRules.useAllRulesWhenTesting.b=false
rule6.ruleName=codeBox
rule6.ruleType.i=1
rule6.expr=(<source lang="lua">)\s*([\s\S]*?)\s*</source>
rule6.groupSource.i=2
rule6.groupTarget.i=-1
rule6.groupName.i=-1
rule6.groupNote.i=1
rule6.preserveWS.b=true
rule6.useCodeFinder.b=false
rule6.sample=This captures the whole "source" structure, it should be sent to the translators as a$0a$coherent whole. It is not recommended to have the CAT tool further segment this.$0a$The first capturing group is used as an identifier.$0a$$0a$<source lang="lua">$0a$function love.load()$0a$   hamster = love.graphics.newImage("hamster.png")$0a$   x = 50$0a$   y = 50$0a$end$0a$function love.draw()$0a$   love.graphics.draw(hamster, x, y)$0a$end$0a$</source>
rule6.codeFinderRules.count.i=0
rule6.codeFinderRules.sample=
rule6.codeFinderRules.useAllRulesWhenTesting.b=false
rule2.codeFinderRules.rule0=\[\[
rule2.codeFinderRules.rule1=]]
rule7.ruleName=tables
rule7.ruleType.i=1
rule7.expr=((\{\|.*?)?[\r\n]+|[|!]|[\r\n]+\|-[\r\n]+)[|!] *([^ -][^|!]*?)(?= *(([|!]|[\r\n]+)[|!])|[\r\n]*\|})
rule7.groupSource.i=3
rule7.groupTarget.i=-1
rule7.groupName.i=-1
rule7.groupNote.i=-1
rule7.preserveWS.b=true
rule7.useCodeFinder.b=false
rule7.sample=This regex matches items in tables.$0a$It's probably the most complicated one in this project.$0a$$0a$It captures things starting with:$0a${| anything newline (| or !)$0a$newline (| or !)$0a$(| or !) doubled$0a$newline |- newline (| or !)$0a$$0a$And then possibly some spaces, then capturing group 3 (the one that captures the$0a$actual text). The "not -" part is to prevent issues caused by line divisions in the table$0a$(|-).$0a$$0a$Followed by possibly some spaces, then one of these:$0a$(| or !) doubled$0a$newline (| or !)$0a$newline |}$0a$$0a${| class="wikitable"$0a$! !! Stopped !! Playing !! Paused$0a$|-$0a$| play() || Play || No change || Play$0a$|-$0a$| stop() || No change || Stop + Rewind || Stop + Rewind$0a$|-$0a$| pause() || No change || Pause || No change$0a$|-$0a$| resume() || No change || No change || Play$0a$|-$0a$| rewind() || No change || Rewind + Play || Rewind + Pause$0a$|}
rule7.codeFinderRules.count.i=0
rule7.codeFinderRules.sample=
rule7.codeFinderRules.useAllRulesWhenTesting.b=false
rule8.ruleName=defListIndent
rule8.ruleType.i=1
rule8.expr=([;:]+ *)([^;:\n\r]*?)((?= *:+)| *$)
rule8.groupSource.i=2
rule8.groupTarget.i=-1
rule8.groupName.i=-1
rule8.groupNote.i=1
rule8.preserveWS.b=true
rule8.useCodeFinder.b=false
rule8.sample=This regex captures text in two different but related (and often combined) structures,$0a$definition list and indent text.$0a$$0a$It necessarily starts with a ";" or one or more ":", possbibly followed by spaces.$0a$The match is also followed by possibly some spaces and a : or a newline; or maybe$0a$the end of line.$0a$$0a$The first capturing group is used as an identifier.$0a$$0a$; 1 : A readable version number, like "0.8.0".$0a$; 2$0a$: A machine-readable version number, like "080".$0a$; type$0a$: If you'd like, you can specify what it is that has been added.$0a$: This should usually be "function", "type" or "variant".$0a$:: Only types that are set to callback, enum, function, module or type will $0a$:: set their ?Since and ?PrettySince parameters.$0a$; text$0a$: Bring out the big guns, and display a totally different text.
rule8.codeFinderRules.count.i=0
rule8.codeFinderRules.sample=
rule8.codeFinderRules.useAllRulesWhenTesting.b=false
rule0.codeFinderRules.rule0=\[{1,2}
rule0.codeFinderRules.rule1=]{1,2}
rule9.ruleName=bullet
rule9.ruleType.i=1
rule9.expr=^(\*) *([^\n\r]*)
rule9.groupSource.i=2
rule9.groupTarget.i=-1
rule9.groupName.i=-1
rule9.groupNote.i=1
rule9.preserveWS.b=true
rule9.useCodeFinder.b=true
rule9.sample=A simple regex that captures bullet lists. The * becomes an identifier.$0a$$0a$* MP3$0a$* Ogg Vorbis$0a$* WAVE$0a$* and just about every tracker format you can think of - XM, MOD, [http://sourceforge.net/p/modplug-xmms/git/ci/master/tree/libmodplug/README#l39 and over twenty others].
rule9.codeFinderRules.count.i=1
rule9.codeFinderRules.sample=Windows XP: <code>C:\Documents and Settings\user\Application Data\LOVE\</code> or <code>%appdata%\LOVE\</code>
rule9.codeFinderRules.useAllRulesWhenTesting.b=true
rule10.ruleName=http
rule10.ruleType.i=1
rule10.expr=^http.*$
rule10.groupSource.i=0
rule10.groupTarget.i=-1
rule10.groupName.i=-1
rule10.groupNote.i=-1
rule10.preserveWS.b=true
rule10.useCodeFinder.b=false
rule10.sample=This is just meant to capture http address added by the serch and replace filter.$0a$That address is not really a part of the translation, it's just there to help the$0a$translators check that page more easily.$0a$$0a$https://www.love2d.org/wiki/love.audio$0a$$0a$https://www.love2d.org/wiki/love.audio.getSourceCount
rule10.codeFinderRules.count.i=0
rule10.codeFinderRules.sample=
rule10.codeFinderRules.useAllRulesWhenTesting.b=false
rule11.ruleName=oldNewInText
rule11.ruleType.i=1
rule11.expr=\{{2}((new|old)in)[^}]*?text=([^|}]*)[^}]*}{2}
rule11.groupSource.i=3
rule11.groupTarget.i=-1
rule11.groupName.i=-1
rule11.groupNote.i=1
rule11.preserveWS.b=true
rule11.useCodeFinder.b=false
rule11.sample=This regex captures all oldin and newin templates with the text property defined.$0a$It may seem unnecessarily complex, since the text is the last parameter defined in$0a$probably all cases. But there's a chance somebody will make it different some day,$0a$so this regex is able to account for any number of arguments before and after the$0a$text. See the examples further below.$0a$$0a$The template name is used as an identifier.$0a$$0a${{oldin|[[0.9.0]]|090|type=function|text=It has been renamed to [[Decoder:getBitDepth]]}}$0a$$0a${{newin|[[0.9.0]]|090|text=It has been renamed to [[Decoder:getBitDepth]]|type=function}}$0a$$0a${{newin|[[0.8.0]]|080|type=function}}$0a$$0a$*"[]" and "[[]]" are no longer treated as inline code, since they're not simple tags, but$0a$complex structures that often require addition of arguments separated by "|".
rule11.codeFinderRules.count.i=0
rule11.codeFinderRules.sample=
rule11.codeFinderRules.useAllRulesWhenTesting.b=false
rule12.ruleName=oldNewInNoText
rule12.ruleType.i=3
rule12.expr=\{{2}(new|old)in(?![^}]*text)[^}]*}{2}
rule12.groupSource.i=-1
rule12.groupTarget.i=-1
rule12.groupName.i=-1
rule12.groupNote.i=-1
rule12.preserveWS.b=true
rule12.useCodeFinder.b=false
rule12.sample=This regex skips all occurrences of oldin and newin that have the text property$0a$defined (as those are picked up by another regex) and matches all newin and oldin$0a$without text, and doesn't extract them.$0a$$0a${{oldin|[[0.9.0]]|090|type=function|text=It has been renamed to [[Decoder:getBitDepth]]}}$0a$$0a${{newin|[[0.9.0]]|090|text=It has been renamed to [[Decoder:getBitDepth]]|type=function}}$0a$$0a${{newin|[[0.8.0]]|080|type=function}}
rule12.codeFinderRules.count.i=0
rule12.codeFinderRules.sample=
rule12.codeFinderRules.useAllRulesWhenTesting.b=false
rule13.ruleName=paramName
rule13.ruleType.i=1
rule13.expr=\{{2}(param)\|[^|]*\|([^|]*)(?=\|[^}]*}{2})
rule13.groupSource.i=2
rule13.groupTarget.i=-1
rule13.groupName.i=-1
rule13.groupNote.i=1
rule13.preserveWS.b=true
rule13.useCodeFinder.b=false
rule13.sample=Captures the argument/return's name in a param template. Notice that the first$0a$argument (light userdata (Português), in the example below) is not captured by any$0a$regex.$0a$$0a$Since this is the first useful argument in the template, let's mark it with an identifier.$0a$It's not possible to mark the other arguments, but this should be a good enough$0a$signal.$0a$$0a${{param|light userdata (Português)|pointer|A raw pointer to the Data.|light userdata}}
rule13.codeFinderRules.count.i=0
rule13.codeFinderRules.sample=
rule13.codeFinderRules.useAllRulesWhenTesting.b=false
rule12.codeFinderRules.rule0=\[{2}
rule12.codeFinderRules.rule1=]{2}
rule0.codeFinderRules.rule2='{2,5}
rule0.codeFinderRules.rule3=<span[^>]*>
rule13.codeFinderRules.rule0=\[{2}
rule13.codeFinderRules.rule1=]{2}
rule14.ruleName=paramDesc
rule14.ruleType.i=1
rule14.expr=\|([^|}]*)(?=\|[^|}]*}{2})
rule14.groupSource.i=1
rule14.groupTarget.i=-1
rule14.groupName.i=-1
rule14.groupNote.i=-1
rule14.preserveWS.b=true
rule14.useCodeFinder.b=false
rule14.sample=Captures a param's description.$0a$The "|" in the lookahead's "[^|}]" prevents it from capturing any other part of the$0a$template.$0a$Must be kept in the end of the list, in order not to conflict other regexes.$0a$$0a${{param|light userdata (Português)|pointer|A raw pointer to the Data.|light userdata}}$0a$$0a$The negated "}" in capturing group 1 prevents it from capturing a big chunk of the$0a$excerpt below.$0a$$0a${{param|light userdata (Português)|pointer|A raw pointer to the Data.|light userdata}}$0a$== See Also ==$0a$* [[parent::Data (Português)]]$0a$* [[Data:getSize]]$0a$* [[Data:getString]]$0a$[[Category:Functions]]$0a${{#set:Description=Gets a pointer to the Data.}}$0a${{#set:Since=000}}$0a$== Other Languages ==$0a${{i18n|Data:getPointer}}
rule14.codeFinderRules.count.i=0
rule14.codeFinderRules.rule0=\[{2}
rule14.codeFinderRules.rule1=]{2}
rule14.codeFinderRules.rule2=\[
rule14.codeFinderRules.rule3=]
rule14.codeFinderRules.sample=
rule14.codeFinderRules.useAllRulesWhenTesting.b=false
rule15.ruleName=paramDisplayName
rule15.ruleType.i=1
rule15.expr=\|(?!\d{3})([^|}]*)}{2}
rule15.groupSource.i=1
rule15.groupTarget.i=-1
rule15.groupName.i=-1
rule15.groupNote.i=-1
rule15.preserveWS.b=true
rule15.useCodeFinder.b=false
rule15.sample=Captures a param's display name.$0a$The "|" in "[^|}]" prevents it from capturing any of the template's arguments.$0a$Must be kept in the end of the list, in order not to conflict with other regexes.$0a$$0a$Notice that the actual link name has already been replaced by the search & replace,$0a$so there's no need for translators to worry about it. Instead, they just translate this$0a$display name.$0a$$0a$The 3 digit negative lookahead (?!\d{3}) is there to prenvent accidental capturing of the$0a$last argument of the New_feature template.$0a$$0a${{param|light userdata (Português)|pointer|A raw pointer to the Data.|light userdata}}$0a$$0a${{New_feature|0.8.0|$0a${{param|mixed (Português)|d (nil)|Fourth event argument.|mixed}}$0a$|080}}
rule15.codeFinderRules.count.i=0
rule15.codeFinderRules.sample=
rule15.codeFinderRules.useAllRulesWhenTesting.b=false
rule1.codeFinderRules.rule0='{2,5}
rule1.codeFinderRules.rule1=</?code>
rule1.codeFinderRules.rule2='{2,5}
rule1.codeFinderRules.rule3=<span[^>]*>
rule15.codeFinderRules.rule0=\[{2}
rule15.codeFinderRules.rule1=]{2}
rule15.codeFinderRules.rule2=\[
rule15.codeFinderRules.rule3=]
rule0.codeFinderRules.rule4=</span>
rule13.codeFinderRules.rule2=\[
rule13.codeFinderRules.rule3=]
rule16.ruleName=transTitle
rule16.ruleType.i=1
rule16.expr=(<(span).*?>.*?</span>)
rule16.groupSource.i=1
rule16.groupTarget.i=-1
rule16.groupName.i=-1
rule16.groupNote.i=2
rule16.preserveWS.b=true
rule16.useCodeFinder.b=true
rule16.sample=This regex captures the translated title of the page, which is inside an HTML span.$0a$"span" is set as the identifier for clarification. The HTML tags will be treated as inline$0a$code.$0a$$0a$<span style="color: #597E9A; font-size: 18pt">An HTML lovely span, wonderful span</span>
rule16.codeFinderRules.count.i=2
rule16.codeFinderRules.sample=<span style="color: #597E9A; font-size: 18pt">Or with an HTML lovely span, wonderful span</span>
rule16.codeFinderRules.useAllRulesWhenTesting.b=true
rule9.codeFinderRules.rule0=</?code>
rule9.codeFinderRules.rule1=]{2}
rule3.codeFinderRules.rule0=\[{2}
rule3.codeFinderRules.rule1=]{2}
rule17.ruleName=paramDisplayName
rule17.ruleType.i=1
rule17.expr=\|([^|}]*)}{2}
rule17.groupSource.i=1
rule17.groupTarget.i=-1
rule17.groupName.i=-1
rule17.groupNote.i=-1
rule17.preserveWS.b=true
rule17.useCodeFinder.b=false
rule17.sample=Captures a param's display name.$0a$The "|" in "[^|}]" prevents it from capturing any of the template's arguments.$0a$Must be kept in the end of the list, in order not to conflict other regexes.$0a$$0a${{param|light userdata (Português)|pointer|A raw pointer to the Data.|light userdata}}
rule17.codeFinderRules.count.i=0
rule17.codeFinderRules.sample=
rule17.codeFinderRules.useAllRulesWhenTesting.b=false
rule10.codeFinderRules.rule0=\[{2}
rule10.codeFinderRules.rule1=]{2}
rule10.codeFinderRules.rule2=\[
rule10.codeFinderRules.rule3=]
rule1.codeFinderRules.rule4=</span>
rule4.codeFinderRules.rule0=\[{2}
rule4.codeFinderRules.rule1=]{2}
rule9.codeFinderRules.rule2=\[
rule9.codeFinderRules.rule3=]
rule11.codeFinderRules.rule0=\[{2}
rule11.codeFinderRules.rule1=]{2}
rule16.codeFinderRules.rule0=<span[^>]*>
rule16.codeFinderRules.rule1=</span>
rule5.codeFinderRules.rule0=(parent|Constructs)::